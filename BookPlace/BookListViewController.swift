//
//  BookListViewController.swift
//  BookPlace
//
//  Created by Artem Lyksa on 3/8/17.
//  Copyright (c) 2017 Artem Lyksa. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so you can apply
//  clean architecture to your iOS and Mac projects, see http://clean-swift.com
//

import UIKit

protocol BookListViewControllerInput
{
    func displayBookList(viewModel: [BookList.GetBookList.ViewModel])
    func displayBookImage(viewModel: BookList.GetBookImage.ViewModel)
}

protocol BookListViewControllerOutput
{
    func getBookList(request: BookList.GetBookList.Request)
    func getImage(request: BookList.GetBookImage.Request)
    func stopLoadingImage(request: BookList.StopLoadingImageProcess.Request)
}

class BookListViewController: UIViewController, BookListViewControllerInput
{
    var output: BookListViewControllerOutput!
    var router: BookListRouter!
    var dataSource: [BookList.GetBookList.ViewModel] = []
    var images: [UIImage?]!
    var heights = [IndexPath:CGFloat]()
    @IBOutlet weak var tableView: UITableView!
    // MARK: - Object lifecycle
    
    override func awakeFromNib()
    {
        super.awakeFromNib()
        BookListConfigurator.sharedInstance.configure(viewController: self)
    }
    
    // MARK: - View lifecycle
    
    override func viewDidLoad()
    {
        super.viewDidLoad()
        tableView.rowHeight = UITableViewAutomaticDimension
        tableView.estimatedRowHeight = 100.0
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        output.stopLoadingImage(request: BookList.StopLoadingImageProcess.Request())
    }
    
    func displayBookList(viewModel: [BookList.GetBookList.ViewModel]) {
        dataSource = viewModel
        images = Array.init(repeating: nil, count: dataSource.count)
        DispatchQueue.main.async {
            self.tableView.reloadData()
        }
    }
    
    func displayBookImage(viewModel: BookList.GetBookImage.ViewModel) {
        images[viewModel.indexPath.row] = viewModel.image
        DispatchQueue.main.async {
            if let visiblePaths = self.tableView.indexPathsForVisibleRows, visiblePaths.contains(viewModel.indexPath) {
                self.tableView.reloadRows(at: [viewModel.indexPath], with: .none)
            }
        }
    }
}

extension BookListViewController: UITableViewDelegate, UITableViewDataSource, UISearchBarDelegate {
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return dataSource.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let bookCell = tableView.dequeueReusableCell(withIdentifier: "bookCell", for: indexPath) as! BookTableViewCell
        let book = dataSource[indexPath.row]
        bookCell.bookNameLabel.text = book.bookName
        bookCell.bookAuthorLabel.text = book.authors
        if let image = images[indexPath.row] {
            bookCell.bookImageView.image = image
        } else {
            output.getImage(request: BookList.GetBookImage.Request(imageURL: book.imageURL, indexPath: indexPath))
        }
        return bookCell
    }
    
    func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) {
        if (cell.frame.size.height > 0) {
            heights[indexPath] = cell.frame.size.height
        }
    }
    
    func tableView(_ tableView: UITableView, estimatedHeightForRowAt indexPath: IndexPath) -> CGFloat {
        if let height = heights[indexPath], height > 10.0 {
            return height
        } else {
            return 100.0
        }
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        tableView.deselectRow(at: indexPath, animated: true)
        //TODO: Go to details scene
    }
    

    func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {
        if let text = searchBar.text, text.characters.count > 0 {
            output.getBookList(request: BookList.GetBookList.Request(searchString: text))
        }
        searchBar.resignFirstResponder()
    }
}
